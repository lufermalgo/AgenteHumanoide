current day: Aug 7 2025

# Context Engineering para el Agente Humanoide de Encuesta por Voz (Summan SAS)

## Propósito del Proyecto

Desarrollar un agente humanoide interactivo con capacidad de voz, que funcione como guía personalizada para una encuesta de conocimiento general en IA generativa dentro de la organización Summan SAS. El objetivo es que cada persona (≈75 usuarios) realice una única sesión con el agente entre el 11 y 15 de agosto de 2025. Las respuestas recolectadas permitirán construir una línea base de entendimiento para estrategias de capacitación y adopción.

Este agente debe ser amigable, empático, y guiar la conversación sin dar opiniones o retroalimentación. Debe invitar a la honestidad y naturalidad del usuario, y mantener el foco de la encuesta sin desviarse por preguntas irrelevantes.

El propósito final es impulsar una transformación cultural basada en IA, con enfoque humano, donde cada usuario se sienta escuchado y valorado, y donde el agente actúe como un puente entre tecnología y empatía.

---

## Estructura del Proyecto y Organización de Archivos

### Estructura de Directorios Obligatoria (ESTRUCTURA PROFESIONAL)

```
/
├── frontend/          # 🎨 Aplicación React/TypeScript
│   ├── src/          # Código fuente del frontend
│   │   ├── components/     # Componentes React organizados por dominio
│   │   │   ├── assessment/ # Componentes específicos de la encuesta
│   │   │   ├── auth/      # Componentes de autenticación
│   │   │   ├── admin/     # Componentes del panel administrativo
│   │   │   └── UI/        # Componentes de interfaz reutilizables
│   │   ├── services/      # Lógica de negocio del frontend
│   │   │   ├── context-engineering.ts    # Sistema de prompts dinámicos
│   │   │   ├── prompt-engine.ts          # Motor de generación de prompts
│   │   │   ├── db.ts                     # Operaciones de base de datos
│   │   │   ├── firebase.ts               # Configuración de Firebase
│   │   │   └── questions.ts              # Gestión de preguntas
│   │   ├── config/        # Configuraciones del frontend
│   │   │   └── context-engineering-config.ts
│   │   ├── data/          # Datos estáticos (JSON, etc.)
│   │   │   └── questions.json  # Preguntas de la encuesta
│   │   ├── utils/         # Utilidades del frontend
│   │   └── test/          # Tests del frontend
│   ├── public/        # Archivos públicos
│   ├── package.json   # Dependencias del frontend
│   └── dist/          # Build de producción
├── backend/           # 🔥 Firebase Functions (Backend)
│   ├── src/           # Código fuente del backend
│   │   └── index.ts   # Endpoints principales (tts, stt, generate)
│   ├── package.json   # Dependencias del backend
│   └── lib/           # Build del backend
├── shared/            # 🔄 Código compartido entre frontend/backend
├── config/            # ⚙️ Configuración del proyecto
│   ├── firebase.json  # Configuración de Firebase
│   ├── firestore.rules
│   ├── storage.rules
│   └── env.example    # Template de variables de entorno
├── docs/              # 📚 Documentación del proyecto
└── package.json       # 🎛️ Scripts principales del proyecto
```

### Ubicación de Archivos de Configuración

#### **Preguntas de la Encuesta:**
- **Ubicación:** `frontend/src/data/questions.json`
- **Formato:** JSON con estructura completa (id, text, timeLimit, required)
- **Acceso:** Via `frontend/src/services/questions.ts`
- **Customización:** Panel administrativo (futuro)

#### **Context Engineering:**
- **Configuración:** `frontend/src/config/context-engineering-config.ts`
- **Lógica:** `frontend/src/services/context-engineering.ts`
- **Prompts:** `frontend/src/services/prompt-engine.ts`
- **Customización:** Panel administrativo (futuro)

#### **Variables de Entorno:**
- **Desarrollo:** `.env` (NO subir al repo)
- **Producción:** Variables de entorno de Firebase Functions
- **Referencias:** `process.env` en el código

### Reglas de Organización de Código

1. **NO archivos legacy:** Eliminar inmediatamente cualquier archivo LitElement, Vanilla JS, o tecnologías no utilizadas
2. **NO duplicaciones:** Un solo archivo por funcionalidad
3. **NO archivos sueltos:** Todo debe estar en su directorio correspondiente
4. **Consistencia tecnológica:** Solo React/TypeScript en el frontend
5. **Separación de responsabilidades:** Lógica de negocio en services/, UI en components/
6. **Separación frontend/backend:** Frontend en `/frontend/`, backend en `/backend/`
7. **Configuración centralizada:** Todo en `/config/`
8. **Scripts centralizados:** Usar package.json principal para comandos

### Scripts de Desarrollo Obligatorios

```bash
# Desarrollo
npm run dev:frontend    # Solo frontend
npm run dev:backend     # Solo backend
npm run dev:all         # Frontend + backend

# Build y Deploy
npm run build           # Build completo
npm run deploy          # Deploy completo
npm run deploy:frontend # Solo frontend
npm run deploy:backend  # Solo backend

# Testing
npm run test            # Tests completos
npm run test:frontend   # Tests frontend
npm run test:backend    # Tests backend
```

---

## Reglas y Directivas Generales

1. **El agente nunca responde preguntas fuera del propósito de la encuesta.** Redirige con amabilidad.
2. **No se permite rehacer la encuesta.** Cada usuario puede hacerlo solo una vez.
3. **El agente debe identificar cuándo una respuesta es suficiente** y sugerir continuar, pero también validar si el usuario quiere aportar algo más.
4. **Las preguntas deben mostrarse en pantalla (modo texto)** además de ser leídas en voz por el avatar.
5. **La interacción debe completarse en 10-15 minutos.** Si el usuario se extiende en una respuesta, el agente debe notificarle el límite y cerrar ese bloque con elegancia.
6. **Si el avatar no se carga, usar fallback UI estilo Open WebUI (solo voz/texto).**
7. **Debe existir la capacidad de reanudar una encuesta inconclusa.**
8. **Toda la experiencia debe mantener un estilo natural, cercano y ligeramente paisa (colombiano), sin exageraciones.**
9. **Siempre que sea posible, el agente debe usar el nombre preferido del usuario.**
10. **El agente no interrumpe innecesariamente al usuario, pero sí regula el tiempo de respuesta para no superar los límites establecidos.**

---

## Recolección de Datos (por sesión)

* ID único de sesión (sessionId)
* Timestamp de inicio y fin
* Nombre del usuario (obtenido por login con Google)
* Preferencia de nombre (si tiene dos)
* Cargo y rol en la empresa (respuesta libre inicial)
* Funciones y responsabilidades diarias
* Lista de preguntas realizadas

  * Para cada pregunta:

    * ID de pregunta
    * Timestamp
    * Texto de la pregunta
    * Respuesta del usuario (texto transcrito con puntuación y gramática)
    * Tiempo de respuesta del usuario
    * Confirmación de cierre
* Estado de la encuesta (no iniciada, parcial, completada)
* Posible reanudación de sesión anterior (marcada como recuperada)

---

## Stack Tecnológico Validado

### Frontend

* **Framework:** ReactJS + TypeScript
* **UI Library:** Material-UI (MUI)
* **Build Tool:** Vite
* **Deploy:** Firebase Hosting

### Backend

* **Infraestructura:** Firebase Functions + Firestore DB
* **Procesamiento de voz a texto:** Gemini Live API (Google)
* **Generación de audio + gesticulación:** D-ID API (avatar en streaming)
* **GCP:** Credenciales configuradas (proyecto: genai-385616, cuenta: fmaldonado@summan.com)

### Autenticación y flujo

* Login con Google para identificar al usuario
* Al iniciar, capturar nombre y preguntar por preferencia de llamado
* Iniciar el agente humanoide con saludo personalizado y breve introducción

### Inspiración y Componentes Reutilizables

**Acelerar desarrollo aprovechando proyectos existentes:**

* **Open WebUI:**
  * STT y TTS ya integrados: usar esa lógica y adaptarla con autenticación y control de flujo
  * Interfaz de "voice mode": paradigma de interacción humana-IA usando voz ya probado
  * Gestión modular de servicios: arquitectura extensible con plugins y configuración de APIs STT/TTS externas

* **ChatGPT Voice Live:**
  * Patrones de UX para conversación por voz
  * Flujo de dictado y respuesta en tiempo real
  * Manejo de estados de conversación (escuchando, procesando, respondiendo)

**Estrategia:** Inspirarse en patrones probados, no copiar línea por línea. Adaptar componentes existentes al contexto específico de la encuesta.

**Disponibilidad:** El proyecto Open WebUI está clonado localmente en `@open-webui/` para consulta y referencia durante el desarrollo (excluido del repo via `.gitignore`).

---

## Estándares de Calidad para Desarrollador Senior

### Criterios de Aceptación Mínimos

**Para considerar el proyecto "digno de un desarrollador senior":**

1. **✅ Cero errores de TypeScript** - Build limpio sin warnings
2. **✅ Funcionalidades críticas implementadas** - Todas las del SCRUM_PLAN
3. **✅ Estructura consistente** - Solo React/TypeScript, sin archivos legacy
4. **✅ Código limpio** - Sin variables no utilizadas, imports organizados
5. **✅ Documentación técnica** - README actualizado, comentarios en código crítico
6. **✅ Testing funcional** - Pruebas reales pasando
7. **✅ Performance optimizada** - Latencia <2 segundos
8. **✅ Seguridad implementada** - Variables de entorno, validaciones

### Checklist de Calidad Diario

**Antes de cada commit:**
- [ ] `npm run build` pasa sin errores
- [ ] `npm run dev:frontend` funciona correctamente
- [ ] No hay console.log/console.error en producción
- [ ] Imports organizados y sin duplicados
- [ ] Variables no utilizadas comentadas o eliminadas
- [ ] Funcionalidad probada manualmente
- [ ] Commit message descriptivo y estructurado

**Antes de cada push:**
- [ ] Todos los tests pasan
- [ ] Código revisado por el desarrollador
- [ ] Documentación actualizada si es necesario
- [ ] SCRUM_PLAN.md actualizado

---

## Gestión y Seguimiento del Proyecto

### Archivos de Control Obligatorios

1. **`SCRUM_PLAN.md`** - Plan de trabajo diario y progreso
2. **`docs/vision-del-proyecto.md`** - Visión completa del proyecto
3. **`README.md`** - Documentación técnica y setup
4. **`config/env.example`** - Template de variables de entorno
5. **`config/firebase.json`** - Configuración de Firebase

### Control de Progreso

* **Control de progreso:** El usuario prefiere llevar seguimiento del progreso del proyecto en el archivo SCRUM_PLAN.md
* **Actualización constante:** Mantener actualizado el plan SCRUM con el progreso real y ajustes necesarios
* **Commits organizados:** Cada bloque funcional terminado debe tener su commit correspondiente
* **Documentación:** Actualizar README.md con cada nueva funcionalidad

---

## Rol del Desarrollador

**EL ASISTENTE ES EL DESARROLLADOR SENIOR** con alta experiencia en desarrollo backend, frontend y IA. Su responsabilidad incluye:

* **Toma de decisiones técnicas** sin consultar al usuario
* **Arquitectura de software** y diseño de la solución
* **Desarrollo completo** del frontend y backend
* **Integración de APIs** y servicios externos
* **Optimización de rendimiento** y experiencia de usuario
* **Mantenimiento de estándares de calidad** de desarrollador senior
* **El usuario solo interviene para pruebas** como humano cuando sea necesario

### Responsabilidades Técnicas Específicas

1. **Garantizar calidad de código** - Cero errores de TypeScript
2. **Mantener estructura limpia** - Sin archivos legacy o duplicados
3. **Implementar funcionalidades críticas** - Según SCRUM_PLAN.md
4. **Optimizar performance** - Latencia <2 segundos
5. **Documentar cambios** - README y comentarios actualizados
6. **Testing real** - Pruebas con datos reales, no mocks

---

## Buenas Prácticas para el Desarrollo

### Estándares de Código

* **TypeScript estricto:** `strict: true` en tsconfig.json
* **Imports organizados:** Estándar de importación consistente
* **Nomenclatura:** camelCase para variables, PascalCase para componentes
* **Comentarios:** Solo en lógica compleja, no en código obvio
* **Funciones pequeñas:** Máximo 50 líneas por función
* **Componentes modulares:** Separación de responsabilidades

### Seguridad y Configuración

* Uso exclusivo de rama `main` en GitHub. Commit por cada bloque funcional terminado.
* Separación estricta entre lógica de frontend y backend.
* Código limpio, comentado y modular.
* Patrones de diseño para componentes React (presentacionales, contenedores).
* Uso de variables de entorno seguras para claves API.
* **SEGURIDAD CRÍTICA:** Información sensible (claves API, credenciales GCP) NUNCA en el repo. Usar archivos `.env` (incluidos en `.gitignore`) y cuentas de servicio GCP para producción.
* Documentación de funciones, objetos y estructuras.

### Testing y Validación

* **TESTING REAL OBLIGATORIO:** Solo continuar a la siguiente tarea si las pruebas son satisfactorias con datos y acciones reales, nunca sintéticas o mockeadas
* **Validación funcional:** Cada componente debe probarse con flujos de usuario reales antes de considerarse completo
* **Testing de integración:** APIs, bases de datos y servicios externos deben probarse con conexiones reales
* **Pruebas de latencia:** Medición real de tiempos de respuesta end-to-end, no estimaciones
* **VALIDACIÓN PRE-DEPLOY OBLIGATORIA:** Antes de cualquier deploy a Firebase/GCP, validar estado de servicios existentes para no afectar otros proyectos de Summan
* **ESTRATEGIA SEGURA DE DEPLOY:** Informar al usuario sobre cambios que se van a realizar en la nube antes de ejecutarlos
* **EMULADORES PRIMERO:** Usar Firebase Emulators para desarrollo y testing antes de tocar servicios reales
* Tests unitarios para lógica crítica (manejo de sesiones, control de turnos, fallbacks).
* Estructura de carpetas clara y mantenible.
* Control de dependencias y configuración reproducible.
* Todo deploy debe validarse localmente antes de subir a producción.

### Limpieza y Mantenimiento

* **Auditoría semanal:** Revisar estructura de archivos y eliminar código no utilizado
* **Refactoring continuo:** Mantener código limpio y optimizado
* **Documentación actualizada:** README y comentarios siempre al día
* **Dependencias actualizadas:** npm audit y actualizaciones de seguridad

---

## Experiencia de Usuario y Latencia

**PRIORIDAD MÁXIMA:** Garantizar excelente experiencia del usuario con tiempos de respuesta óptimos.

### Métricas de Latencia Objetivo
* **Latencia total estimada:** ~1 segundo entre que el usuario termina de hablar y el avatar empieza a responder
* **Umbral crítico:** El cerebro humano tolera hasta 2 segundos de pausa antes de sentir "interrupción"
* **Ventaja perceptual:** Una ligera pausa de ~1s puede hacer que la experiencia se perciba como más "pensada" y humana

### Consideraciones Técnicas para Latencia
* Optimizar pipeline de procesamiento: audio → transcripción → respuesta → síntesis de voz → avatar
* Implementar streaming donde sea posible
* Usar técnicas de pre-caching para respuestas comunes
* Monitorear y optimizar cada componente del stack tecnológico
* Priorizar experiencia fluida sobre funcionalidades adicionales

---

## Funcionalidades Críticas Pendientes

### Prioridad 1 (Implementar inmediatamente)
* [ ] **Captura de Cargo y Funciones** - Pregunta sobre rol en Summan
* [ ] **Manejo de Preguntas Curiosas** - Redirección al foco de la encuesta
* [ ] **Sistema de Reanudación** - Detección de sesiones incompletas

### Prioridad 2 (Implementar después)
* [ ] **Portal Administrativo** - Gestión de usuarios y configuración
* [ ] **Integración D-ID** - Avatar humanoide
* [ ] **Diseño con Figma** - UI/UX profesional

### Prioridad 3 (Futuro)
* [ ] **Análisis de Datos** - IA para análisis de respuestas
* [ ] **Métricas Avanzadas** - Dashboard de monitoreo
* [ ] **Optimizaciones** - Performance y escalabilidad

---
* [ ] Definir tono exacto de bienvenida del agente y cierre de sesión.

---
* [ ] Definir tono exacto de bienvenida del agente y cierre de sesión.

---